
/home/horkheimer/coding/nts1/logue-sdk/platform/nutekt-digital/waves/build/dbtest.elf:     file format elf32-littlearm


Disassembly of section .text:

20000048 <_text_start>:
  (void)api;
}

__attribute__((weak))
void _hook_cycle(const user_osc_param_t * const params, int32_t *yn, const uint32_t frames)
{
20000048:	4770      	bx	lr

2000004a <_hook_mute>:
  (void)params;
}

__attribute__((weak))
void _hook_mute(const user_osc_param_t * const params)
{
2000004a:	4770      	bx	lr

2000004c <_hook_value>:
  (void)params;
}

__attribute__((weak))
void _hook_value(uint16_t value)
{
2000004c:	4770      	bx	lr
  (void)value;
}

__attribute__((weak))
void _hook_param(uint16_t index, uint16_t value)
{
2000004e:	4770      	bx	lr
20000050:	4770      	bx	lr
20000052:	4770      	bx	lr
  _hook_init(platform, api);
}

__attribute__((weak))
void _hook_init(uint32_t platform, uint32_t api)
{
20000054:	4770      	bx	lr

20000056 <_entry>:
 * @{
 */

__attribute__((used))
void _entry(uint32_t platform, uint32_t api)
{
20000056:	4b10      	ldr	r3, [pc, #64]	; (20000098 <_entry+0x42>)
20000058:	4a10      	ldr	r2, [pc, #64]	; (2000009c <_entry+0x46>)
2000005a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2000005e:	4688      	mov	r8, r1
20000060:	4607      	mov	r7, r0
  // Ensure zero-clear BSS segment
  uint8_t * __restrict bss_p = (uint8_t *)&_bss_start;
  const uint8_t * const bss_e = (uint8_t *)&_bss_end;

  for (; bss_p != bss_e;)
    *(bss_p++) = 0;
20000062:	2100      	movs	r1, #0
{
  // Ensure zero-clear BSS segment
  uint8_t * __restrict bss_p = (uint8_t *)&_bss_start;
  const uint8_t * const bss_e = (uint8_t *)&_bss_end;

  for (; bss_p != bss_e;)
20000064:	4293      	cmp	r3, r2
20000066:	d002      	beq.n	2000006e <_entry+0x18>
    *(bss_p++) = 0;
20000068:	f803 1f01 	strb.w	r1, [r3, #1]!
2000006c:	e7fa      	b.n	20000064 <_entry+0xe>
2000006e:	4b0c      	ldr	r3, [pc, #48]	; (200000a0 <_entry+0x4a>)
20000070:	4c0c      	ldr	r4, [pc, #48]	; (200000a4 <_entry+0x4e>)
20000072:	1ae4      	subs	r4, r4, r3
20000074:	10a4      	asrs	r4, r4, #2

  // Call constructors if any.  
  const size_t count = __init_array_end - __init_array_start;
  for (size_t i = 0; i<count; ++i) {
20000076:	2500      	movs	r5, #0
20000078:	461e      	mov	r6, r3
2000007a:	42a5      	cmp	r5, r4
2000007c:	d005      	beq.n	2000008a <_entry+0x34>
    __init_fptr init_p = (__init_fptr)__init_array_start[i];
2000007e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    if (init_p != NULL)
20000082:	b103      	cbz	r3, 20000086 <_entry+0x30>
      init_p();
20000084:	4798      	blx	r3
  for (; bss_p != bss_e;)
    *(bss_p++) = 0;

  // Call constructors if any.  
  const size_t count = __init_array_end - __init_array_start;
  for (size_t i = 0; i<count; ++i) {
20000086:	3501      	adds	r5, #1
20000088:	e7f7      	b.n	2000007a <_entry+0x24>
    if (init_p != NULL)
      init_p();
  }
  
  // Call user initialization
  _hook_init(platform, api);
2000008a:	4641      	mov	r1, r8
2000008c:	4638      	mov	r0, r7
2000008e:	f000 f80b 	bl	200000a8 <_hook_init>
20000092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20000096:	bf00      	nop
20000098:	200008bf 	.word	0x200008bf
2000009c:	2000094f 	.word	0x2000094f
200000a0:	20000040 	.word	0x20000040
200000a4:	20000044 	.word	0x20000044

200000a8 <_hook_init>:
#include "waves.hpp"
#include "utils/float_math.h"
static Waves s_waves;

void OSC_INIT(uint32_t platform, uint32_t api)
{
200000a8:	4770      	bx	lr

200000aa <_hook_cycle>:
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Waves::State &s = s_waves.state;
  const Waves::Params &p = s_waves.params;

  // Handle events.
  {
    const uint32_t flags = s.flags;
200000ae:	4cdd      	ldr	r4, [pc, #884]	; (20000424 <_hook_cycle+0x37a>)
    s.flags = Waves::k_flags_none;
    
    s_waves.updatePitch(osc_w0f_for_note((params->pitch)>>8, params->pitch & 0xFF));
200000b0:	8886      	ldrh	r6, [r0, #4]
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200000b2:	4fdd      	ldr	r7, [pc, #884]	; (20000428 <_hook_cycle+0x37e>)

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200000b4:	ed9f 6add 	vldr	s12, [pc, #884]	; 2000042c <_hook_cycle+0x382>
  const Waves::Params &p = s_waves.params;

  // Handle events.
  {
    const uint32_t flags = s.flags;
    s.flags = Waves::k_flags_none;
200000b8:	2300      	movs	r3, #0
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000ba:	460d      	mov	r5, r1
  Waves::State &s = s_waves.state;
  const Waves::Params &p = s_waves.params;

  // Handle events.
  {
    const uint32_t flags = s.flags;
200000bc:	f894 103c 	ldrb.w	r1, [r4, #60]	; 0x3c
    s.flags = Waves::k_flags_none;
200000c0:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    
    s_waves.updatePitch(osc_w0f_for_note((params->pitch)>>8, params->pitch & 0xFF));
200000c4:	1233      	asrs	r3, r6, #8
200000c6:	2b96      	cmp	r3, #150	; 0x96
200000c8:	b2f6      	uxtb	r6, r6
200000ca:	ee07 6a90 	vmov	s15, r6
200000ce:	bfd8      	it	le
200000d0:	461e      	movle	r6, r3
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
200000d2:	f103 0301 	add.w	r3, r3, #1
200000d6:	b2db      	uxtb	r3, r3
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200000d8:	bfc8      	it	gt
200000da:	2697      	movgt	r6, #151	; 0x97
200000dc:	2b96      	cmp	r3, #150	; 0x96
200000de:	bf88      	it	hi
200000e0:	2397      	movhi	r3, #151	; 0x97
200000e2:	eb07 0686 	add.w	r6, r7, r6, lsl #2
200000e6:	eb07 0383 	add.w	r3, r7, r3, lsl #2
200000ea:	ed96 7a00 	vldr	s14, [r6]
200000ee:	edd3 6a00 	vldr	s13, [r3]
200000f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
200000f6:	ee76 6ac7 	vsub.f32	s13, s13, s14
200000fa:	ee67 7a86 	vmul.f32	s15, s15, s12
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000fe:	ed2d 8b10 	vpush	{d8-d15}
20000102:	eea6 7aa7 	vfma.f32	s14, s13, s15
    prelpf.mCoeffs.setPoleLP(0.8f);
    postlpf.mCoeffs.setFOLP(osc_tanpif(0.45f));
  }
  
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
20000106:	eddf 6aca 	vldr	s13, [pc, #808]	; 20000430 <_hook_cycle+0x386>
2000010a:	eef0 7a47 	vmov.f32	s15, s14

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000010e:	ed9f 7ac9 	vldr	s14, [pc, #804]	; 20000434 <_hook_cycle+0x38a>
20000112:	eef4 7ac7 	vcmpe.f32	s15, s14
20000116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000011a:	bfa8      	it	ge
2000011c:	eef0 7a47 	vmovge.f32	s15, s14
20000120:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
20000124:	eea7 7aa6 	vfma.f32	s14, s15, s13
    // Sub one octave and a phase drift (0.15Hz@48KHz)
    state.w0sub = 0.5f * w0 + drift * 3.125e-006f;
  }
    
  inline void updateWaves(const uint16_t flags) {
    if (flags & k_flag_wave0) {
20000128:	078e      	lsls	r6, r1, #30
    postlpf.mCoeffs.setFOLP(osc_tanpif(0.45f));
  }
  
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
    const float drift = params.shiftshape;
2000012a:	edd4 7a14 	vldr	s15, [r4, #80]	; 0x50
    state.w00 = w0;
    // Alt osc with slight drift (0.25Hz@48KHz)
    state.w01 = w0 + drift * 5.20833333333333e-006f;
2000012e:	eddf 6ac2 	vldr	s13, [pc, #776]	; 20000438 <_hook_cycle+0x38e>
  }
  
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
    const float drift = params.shiftshape;
    state.w00 = w0;
20000132:	ed84 7a06 	vstr	s14, [r4, #24]
    // Alt osc with slight drift (0.25Hz@48KHz)
    state.w01 = w0 + drift * 5.20833333333333e-006f;
20000136:	eeb0 6a47 	vmov.f32	s12, s14
2000013a:	eea7 6aa6 	vfma.f32	s12, s15, s13
    // Sub one octave and a phase drift (0.15Hz@48KHz)
    state.w0sub = 0.5f * w0 + drift * 3.125e-006f;
2000013e:	eddf 6abf 	vldr	s13, [pc, #764]	; 2000043c <_hook_cycle+0x392>
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
    const float drift = params.shiftshape;
    state.w00 = w0;
    // Alt osc with slight drift (0.25Hz@48KHz)
    state.w01 = w0 + drift * 5.20833333333333e-006f;
20000142:	ed84 6a07 	vstr	s12, [r4, #28]
    // Sub one octave and a phase drift (0.15Hz@48KHz)
    state.w0sub = 0.5f * w0 + drift * 3.125e-006f;
20000146:	ee67 7aa6 	vmul.f32	s15, s15, s13
2000014a:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
2000014e:	eee7 7a26 	vfma.f32	s15, s14, s13
20000152:	edc4 7a08 	vstr	s15, [r4, #32]
  }
    
  inline void updateWaves(const uint16_t flags) {
    if (flags & k_flag_wave0) {
20000156:	d511      	bpl.n	2000017c <_hook_cycle+0xd2>
      static const uint8_t k_a_thr = k_waves_a_cnt;
      static const uint8_t k_b_thr = k_a_thr + k_waves_b_cnt;
      static const uint8_t k_c_thr = k_b_thr + k_waves_c_cnt;
      
      uint8_t idx = params.wave0;
20000158:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
      const float * const * table;
      
      if (idx < k_a_thr) {
2000015c:	2b0f      	cmp	r3, #15
2000015e:	d909      	bls.n	20000174 <_hook_cycle+0xca>
        table = wavesA;
      }
      else if (idx < k_b_thr) {
20000160:	2b1f      	cmp	r3, #31
        table = wavesB;
        idx -= k_a_thr;
20000162:	bf97      	itett	ls
20000164:	3b10      	subls	r3, #16
      }
      else { 
        table = wavesC;
        idx -= k_b_thr;
20000166:	3b20      	subhi	r3, #32
      if (idx < k_a_thr) {
        table = wavesA;
      }
      else if (idx < k_b_thr) {
        table = wavesB;
        idx -= k_a_thr;
20000168:	b2db      	uxtbls	r3, r3
      
      if (idx < k_a_thr) {
        table = wavesA;
      }
      else if (idx < k_b_thr) {
        table = wavesB;
2000016a:	4eb5      	ldrls	r6, [pc, #724]	; (20000440 <_hook_cycle+0x396>)
        idx -= k_a_thr;
      }
      else { 
        table = wavesC;
2000016c:	bf84      	itt	hi
2000016e:	4eb5      	ldrhi	r6, [pc, #724]	; (20000444 <_hook_cycle+0x39a>)
        idx -= k_b_thr;
20000170:	b2db      	uxtbhi	r3, r3
20000172:	e000      	b.n	20000176 <_hook_cycle+0xcc>
      
      uint8_t idx = params.wave0;
      const float * const * table;
      
      if (idx < k_a_thr) {
        table = wavesA;
20000174:	4eb4      	ldr	r6, [pc, #720]	; (20000448 <_hook_cycle+0x39e>)
      }
      else { 
        table = wavesC;
        idx -= k_b_thr;
      }
      state.wave0 = table[idx];
20000176:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
2000017a:	6023      	str	r3, [r4, #0]
    }
    if (flags & k_flag_wave1) {
2000017c:	074b      	lsls	r3, r1, #29
2000017e:	d511      	bpl.n	200001a4 <_hook_cycle+0xfa>
      static const uint8_t k_d_thr = k_waves_d_cnt;
      static const uint8_t k_e_thr = k_d_thr + k_waves_e_cnt;
      static const uint8_t k_f_thr = k_e_thr + k_waves_f_cnt;
      
      uint8_t idx = params.wave1;
20000180:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
      const float * const * table;
      
      if (idx < k_d_thr) {
20000184:	2b0c      	cmp	r3, #12
20000186:	d909      	bls.n	2000019c <_hook_cycle+0xf2>
        table = wavesD;
      }
      else if (idx < k_e_thr) {
20000188:	2b1b      	cmp	r3, #27
        table = wavesE;
        idx -= k_d_thr;
2000018a:	bf97      	itett	ls
2000018c:	3b0d      	subls	r3, #13
      }
      else { // if (idx < k_f_thr) {
        table = wavesF;
        idx -= k_e_thr;
2000018e:	3b1c      	subhi	r3, #28
      if (idx < k_d_thr) {
        table = wavesD;
      }
      else if (idx < k_e_thr) {
        table = wavesE;
        idx -= k_d_thr;
20000190:	b2db      	uxtbls	r3, r3
      
      if (idx < k_d_thr) {
        table = wavesD;
      }
      else if (idx < k_e_thr) {
        table = wavesE;
20000192:	4eae      	ldrls	r6, [pc, #696]	; (2000044c <_hook_cycle+0x3a2>)
        idx -= k_d_thr;
      }
      else { // if (idx < k_f_thr) {
        table = wavesF;
20000194:	bf84      	itt	hi
20000196:	4eae      	ldrhi	r6, [pc, #696]	; (20000450 <_hook_cycle+0x3a6>)
        idx -= k_e_thr;
20000198:	b2db      	uxtbhi	r3, r3
2000019a:	e000      	b.n	2000019e <_hook_cycle+0xf4>
      
      uint8_t idx = params.wave1;
      const float * const * table;
      
      if (idx < k_d_thr) {
        table = wavesD;
2000019c:	4ead      	ldr	r6, [pc, #692]	; (20000454 <_hook_cycle+0x3aa>)
      else { // if (idx < k_f_thr) {
        table = wavesF;
        idx -= k_e_thr;
      }
      
      state.wave1 = table[idx];
2000019e:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
200001a2:	6063      	str	r3, [r4, #4]
    }
    if (flags & k_flag_subwave) {
200001a4:	070f      	lsls	r7, r1, #28
      const uint8_t idx = params.subwave;
      state.subwave = wavesA[params.subwave];
200001a6:	bf44      	itt	mi
200001a8:	4ba7      	ldrmi	r3, [pc, #668]	; (20000448 <_hook_cycle+0x39e>)
200001aa:	f894 6056 	ldrbmi.w	r6, [r4, #86]	; 0x56
    s_waves.updateWaves(flags);
    
    if (flags & Waves::k_flag_reset)
      s.reset();
    
    s.lfo = q31_to_f32(params->shape_lfo);
200001ae:	ed90 7a00 	vldr	s14, [r0]
200001b2:	bf44      	itt	mi
200001b4:	f853 3026 	ldrmi.w	r3, [r3, r6, lsl #2]
200001b8:	60a3      	strmi	r3, [r4, #8]
    
    s_waves.updatePitch(osc_w0f_for_note((params->pitch)>>8, params->pitch & 0xFF));
    
    s_waves.updateWaves(flags);
    
    if (flags & Waves::k_flag_reset)
200001ba:	064e      	lsls	r6, r1, #25
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
    }
    
    inline void reset(void)
    {
      phi0 = 0;
200001bc:	bf48      	it	mi
200001be:	2300      	movmi	r3, #0
      s.reset();
    
    s.lfo = q31_to_f32(params->shape_lfo);
200001c0:	eeba 7ae0 	vcvt.f32.s32	s14, s14, #31
200001c4:	bf42      	ittt	mi
200001c6:	60e3      	strmi	r3, [r4, #12]
      phi1 = 0;
200001c8:	6123      	strmi	r3, [r4, #16]
      phisub = 0;
200001ca:	6163      	strmi	r3, [r4, #20]

    if (flags & Waves::k_flag_bitcrush) {
200001cc:	0689      	lsls	r1, r1, #26
    s_waves.updateWaves(flags);
    
    if (flags & Waves::k_flag_reset)
      s.reset();
    
    s.lfo = q31_to_f32(params->shape_lfo);
200001ce:	4b95      	ldr	r3, [pc, #596]	; (20000424 <_hook_cycle+0x37a>)
200001d0:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24

    if (flags & Waves::k_flag_bitcrush) {
200001d4:	d52a      	bpl.n	2000022c <_hook_cycle+0x182>
      s.dither = p.bitcrush * 2e-008f;
200001d6:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
200001da:	eddf 6a9f 	vldr	s13, [pc, #636]	; 20000458 <_hook_cycle+0x3ae>
   * @note       Fractional bit depth, exponentially mapped, 1 to 24 bits.
   */
  __fast_inline float osc_bitresf(float x) {
    const float xf = x * k_bitres_size;
    const uint32_t xi = (uint32_t)xf;
    const float y0 = bitres_lut_f[xi];
200001de:	499f      	ldr	r1, [pc, #636]	; (2000045c <_hook_cycle+0x3b2>)
200001e0:	ee67 6aa6 	vmul.f32	s13, s15, s13
200001e4:	edc3 6a0b 	vstr	s13, [r3, #44]	; 0x2c
   * @param   x  Value in [0, 1.0].
   * @return     Quantization scaling factor.
   * @note       Fractional bit depth, exponentially mapped, 1 to 24 bits.
   */
  __fast_inline float osc_bitresf(float x) {
    const float xf = x * k_bitres_size;
200001e8:	eddf 6a9d 	vldr	s13, [pc, #628]	; 20000460 <_hook_cycle+0x3b6>
200001ec:	ee67 7aa6 	vmul.f32	s15, s15, s13
    const uint32_t xi = (uint32_t)xf;
200001f0:	eefc 6ae7 	vcvt.u32.f32	s13, s15
200001f4:	ee16 0a90 	vmov	r0, s13

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200001f8:	ee06 0a10 	vmov	s12, r0
200001fc:	eeb8 6a46 	vcvt.f32.u32	s12, s12
    const float y0 = bitres_lut_f[xi];
20000200:	eb01 0680 	add.w	r6, r1, r0, lsl #2
20000204:	ee77 7ac6 	vsub.f32	s15, s15, s12
20000208:	edd6 6a00 	vldr	s13, [r6]
2000020c:	ed96 6a01 	vldr	s12, [r6, #4]
20000210:	ee36 6a66 	vsub.f32	s12, s12, s13
20000214:	eee7 6a86 	vfma.f32	s13, s15, s12
      s.bitres = osc_bitresf(p.bitcrush);
      s.bitresrcp = 1.f / s.bitres;
20000218:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
2000021c:	eef0 7a66 	vmov.f32	s15, s13
    
    s.lfo = q31_to_f32(params->shape_lfo);

    if (flags & Waves::k_flag_bitcrush) {
      s.dither = p.bitcrush * 2e-008f;
      s.bitres = osc_bitresf(p.bitcrush);
20000220:	edc3 6a0c 	vstr	s13, [r3, #48]	; 0x30
      s.bitresrcp = 1.f / s.bitres;
20000224:	eec6 6a27 	vdiv.f32	s13, s12, s15
20000228:	edc3 6a0d 	vstr	s13, [r3, #52]	; 0x34
  // Temporaries.
  float phi0 = s.phi0;
  float phi1 = s.phi1;
  float phisub = s.phisub;

  float lfoz = s.lfoz;
2000022c:	edd4 ca0a 	vldr	s25, [r4, #40]	; 0x28
      s.bitresrcp = 1.f / s.bitres;
    }
  }
  
  // Temporaries.
  float phi0 = s.phi0;
20000230:	ed94 ca03 	vldr	s24, [r4, #12]
  float phi1 = s.phi1;
20000234:	edd4 ba04 	vldr	s23, [r4, #16]
  float phisub = s.phisub;
20000238:	ed94 ba05 	vldr	s22, [r4, #20]
  const float ditheramt = p.bitcrush * 2e-008f;
  
  const float bitres = osc_bitresf(p.bitcrush);
  const float bitres_recip = 1.f / bitres;

  const float submix = p.submix;
2000023c:	edd4 8a10 	vldr	s17, [r4, #64]	; 0x40
  const float ringmix = p.ringmix;
20000240:	ed94 9a11 	vldr	s18, [r4, #68]	; 0x44
  extern const float * const wavesF[k_waves_f_cnt];
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
20000244:	ed9f da86 	vldr	s26, [pc, #536]	; 20000460 <_hook_cycle+0x3b6>

    //const float wavemix = clipminmaxf(0.005f, p.shape+lfoz, 0.995f);
    const float wavemix = clipminmaxf(0.005f, 0, 0.995f);
    
    float sig = (1.f - wavemix) * osc_wave_scanf(s.wave0, phi0);
    sig += wavemix * osc_wave_scanf(s.wave1, phi1);
20000248:	ed9f aa86 	vldr	s20, [pc, #536]	; 20000464 <_hook_cycle+0x3ba>
2000024c:	eddf aa86 	vldr	s21, [pc, #536]	; 20000468 <_hook_cycle+0x3be>
  float phi0 = s.phi0;
  float phi1 = s.phi1;
  float phisub = s.phisub;

  float lfoz = s.lfoz;
  const float lfo_inc = (s.lfo - lfoz) / frames;
20000250:	ee07 2a90 	vmov	s15, r2
20000254:	ee37 7a6c 	vsub.f32	s14, s14, s25
20000258:	eef8 7a67 	vcvt.f32.u32	s15, s15
  
  dsp::BiQuad &prelpf = s_waves.prelpf;
  dsp::BiQuad &postlpf = s_waves.postlpf;
  
  q31_t * __restrict y = (q31_t *)yn;
  const q31_t * y_e = y + frames;
2000025c:	eb05 0682 	add.w	r6, r5, r2, lsl #2
  float phi0 = s.phi0;
  float phi1 = s.phi1;
  float phisub = s.phisub;

  float lfoz = s.lfoz;
  const float lfo_inc = (s.lfo - lfoz) / frames;
20000260:	eec7 9a27 	vdiv.f32	s19, s14, s15
  dsp::BiQuad &postlpf = s_waves.postlpf;
  
  q31_t * __restrict y = (q31_t *)yn;
  const q31_t * y_e = y + frames;
  
  for (; y != y_e; ) {
20000264:	42b5      	cmp	r5, r6
20000266:	f000 819b 	beq.w	200005a0 <_hook_cycle+0x4f6>

    //const float wavemix = clipminmaxf(0.005f, p.shape+lfoz, 0.995f);
    const float wavemix = clipminmaxf(0.005f, 0, 0.995f);
    
    float sig = (1.f - wavemix) * osc_wave_scanf(s.wave0, phi0);
2000026a:	6820      	ldr	r0, [r4, #0]
    sig += wavemix * osc_wave_scanf(s.wave1, phi1);
2000026c:	6861      	ldr	r1, [r4, #4]
2000026e:	eebc 7acc 	vcvt.u32.f32	s14, s24
20000272:	eefc 7aeb 	vcvt.u32.f32	s15, s23
20000276:	eeb8 7a47 	vcvt.f32.u32	s14, s14
2000027a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2000027e:	ee3c 7a47 	vsub.f32	s14, s24, s14
20000282:	ee7b 7ae7 	vsub.f32	s15, s23, s15
20000286:	ee27 7a0d 	vmul.f32	s14, s14, s26
2000028a:	ee67 7a8d 	vmul.f32	s15, s15, s26
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
2000028e:	eebc 5ac7 	vcvt.u32.f32	s10, s14
20000292:	eefc 5ae7 	vcvt.u32.f32	s11, s15
20000296:	ee15 3a10 	vmov	r3, s10
2000029a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_waves_mask;
    return linintf(x0f - (uint32_t)x0f, w[x0], w[x1]);
2000029e:	eb00 0382 	add.w	r3, r0, r2, lsl #2
200002a2:	3201      	adds	r2, #1
200002a4:	ed93 6a00 	vldr	s12, [r3]
200002a8:	eeb8 5a45 	vcvt.f32.u32	s10, s10
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
200002ac:	ee15 3a90 	vmov	r3, s11
    const uint32_t x1 = (x0 + 1) & k_waves_mask;
    return linintf(x0f - (uint32_t)x0f, w[x0], w[x1]);
200002b0:	f002 027f 	and.w	r2, r2, #127	; 0x7f
200002b4:	eb00 0282 	add.w	r2, r0, r2, lsl #2
200002b8:	ee37 7a45 	vsub.f32	s14, s14, s10
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
200002bc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
200002c0:	ed92 5a00 	vldr	s10, [r2]
    
    const float subsig = osc_wave_scanf(s.subwave, phisub);
200002c4:	68a2      	ldr	r2, [r4, #8]
    const uint32_t x1 = (x0 + 1) & k_waves_mask;
    return linintf(x0f - (uint32_t)x0f, w[x0], w[x1]);
200002c6:	eb01 0783 	add.w	r7, r1, r3, lsl #2
200002ca:	3301      	adds	r3, #1

    //const float wavemix = clipminmaxf(0.005f, p.shape+lfoz, 0.995f);
    const float wavemix = clipminmaxf(0.005f, 0, 0.995f);
    
    float sig = (1.f - wavemix) * osc_wave_scanf(s.wave0, phi0);
    sig += wavemix * osc_wave_scanf(s.wave1, phi1);
200002cc:	ee35 5a46 	vsub.f32	s10, s10, s12
200002d0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
200002d4:	eb01 0383 	add.w	r3, r1, r3, lsl #2
200002d8:	eea7 6a05 	vfma.f32	s12, s14, s10
200002dc:	edd7 6a00 	vldr	s13, [r7]
200002e0:	ed93 7a00 	vldr	s14, [r3]
200002e4:	eef8 5a65 	vcvt.f32.u32	s11, s11
200002e8:	ee37 7a66 	vsub.f32	s14, s14, s13
200002ec:	ee77 7ae5 	vsub.f32	s15, s15, s11
200002f0:	eebf ea00 	vmov.f32	s28, #240	; 0xbf800000 -1.0
200002f4:	eee7 6a87 	vfma.f32	s13, s15, s14
  extern const float * const wavesF[k_waves_f_cnt];
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
200002f8:	eebc 7acb 	vcvt.u32.f32	s14, s22
200002fc:	ee66 6a8a 	vmul.f32	s13, s13, s20
20000300:	eeb8 7a47 	vcvt.f32.u32	s14, s14
20000304:	eee6 6a2a 	vfma.f32	s13, s12, s21
20000308:	ee3b 7a47 	vsub.f32	s14, s22, s14
2000030c:	ee27 7a0d 	vmul.f32	s14, s14, s26
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
20000310:	eebc 6ac7 	vcvt.u32.f32	s12, s14
20000314:	ee16 3a10 	vmov	r3, s12
20000318:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_waves_mask;
    return linintf(x0f - (uint32_t)x0f, w[x0], w[x1]);
2000031c:	eb02 0183 	add.w	r1, r2, r3, lsl #2
20000320:	3301      	adds	r3, #1
20000322:	eeb8 6a46 	vcvt.f32.u32	s12, s12
20000326:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2000032a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
2000032e:	ee37 7a46 	vsub.f32	s14, s14, s12
20000332:	edd1 7a00 	vldr	s15, [r1]
20000336:	ed93 6a00 	vldr	s12, [r3]
2000033a:	ee36 6a67 	vsub.f32	s12, s12, s15
2000033e:	eee7 7a06 	vfma.f32	s15, s14, s12
    
    const float subsig = osc_wave_scanf(s.subwave, phisub);
    sig = (1.f - submix) * sig + submix * subsig;
20000342:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
20000346:	ee28 6aa7 	vmul.f32	s12, s17, s15
2000034a:	ee77 5a68 	vsub.f32	s11, s14, s17
2000034e:	eef0 da47 	vmov.f32	s27, s14
20000352:	eea6 6aa5 	vfma.f32	s12, s13, s11
    sig = (1.f - ringmix) * sig + ringmix * (subsig * sig);
20000356:	ee66 7a27 	vmul.f32	s15, s12, s15
    
    float sig = (1.f - wavemix) * osc_wave_scanf(s.wave0, phi0);
    sig += wavemix * osc_wave_scanf(s.wave1, phi1);
    
    const float subsig = osc_wave_scanf(s.subwave, phisub);
    sig = (1.f - submix) * sig + submix * subsig;
2000035a:	eef0 6a46 	vmov.f32	s13, s12
    sig = (1.f - ringmix) * sig + ringmix * (subsig * sig);
2000035e:	ee67 7a89 	vmul.f32	s15, s15, s18
20000362:	ee37 6a49 	vsub.f32	s12, s14, s18
20000366:	eee6 7a86 	vfma.f32	s15, s13, s12

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000036a:	ee77 6a87 	vadd.f32	s13, s15, s14
2000036e:	eef5 6ac0 	vcmpe.f32	s13, #0.0
20000372:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000376:	db07      	blt.n	20000388 <_hook_cycle+0x2de>
20000378:	eef4 7ac7 	vcmpe.f32	s15, s14
2000037c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000380:	bfa8      	it	ge
20000382:	eef0 7a47 	vmovge.f32	s15, s14
20000386:	e001      	b.n	2000038c <_hook_cycle+0x2e2>
20000388:	eef0 7a4e 	vmov.f32	s15, s28
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
2000038c:	ed94 7a16 	vldr	s14, [r4, #88]	; 0x58
20000390:	ed94 8a1b 	vldr	s16, [r4, #108]	; 0x6c
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
20000394:	edd4 6a17 	vldr	s13, [r4, #92]	; 0x5c
    sig = clip1m1f(sig);
    
    sig = prelpf.process_fo(sig);
    sig += s.dither * osc_white();
20000398:	edd4 ea0b 	vldr	s29, [r4, #44]	; 0x2c
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
2000039c:	eea7 8a27 	vfma.f32	s16, s14, s15
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
200003a0:	ed94 7a19 	vldr	s14, [r4, #100]	; 0x64
200003a4:	ee27 7a48 	vnmul.f32	s14, s14, s16
200003a8:	eea6 7aa7 	vfma.f32	s14, s13, s15
200003ac:	ed84 7a1b 	vstr	s14, [r4, #108]	; 0x6c
   * @return     Value in [-1.0, 1.0].
   */
  float _osc_white(void);

  __fast_inline float osc_white(void) {
    return _osc_white();
200003b0:	f000 fa80 	bl	200008b4 <___osc_white_veneer>
    sig = si_roundf(sig * s.bitres) * s.bitresrcp;
200003b4:	eeae 8a80 	vfma.f32	s16, s29, s0
200003b8:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
200003bc:	edd4 6a1d 	vldr	s13, [r4, #116]	; 0x74
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
200003c0:	ed94 6a1e 	vldr	s12, [r4, #120]	; 0x78
200003c4:	ee28 8a07 	vmul.f32	s16, s16, s14
200003c8:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
{
  f32_t xs = {x};
  f32_t ys = {y};
  
  xs.i &= 0x7fffffff;
  xs.i |= ys.i & 0x80000000;
200003cc:	ee18 3a10 	vmov	r3, s16
200003d0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
200003d4:	f043 537c 	orr.w	r3, r3, #1056964608	; 0x3f000000
200003d8:	ee07 3a90 	vmov	s15, r3
200003dc:	ee38 8a27 	vadd.f32	s16, s16, s15
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
200003e0:	edd4 7a22 	vldr	s15, [r4, #136]	; 0x88
200003e4:	eebd 8ac8 	vcvt.s32.f32	s16, s16
200003e8:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
200003ec:	ee28 7a07 	vmul.f32	s14, s16, s14
200003f0:	eee7 7a26 	vfma.f32	s15, s14, s13
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
200003f4:	edd4 6a20 	vldr	s13, [r4, #128]	; 0x80
200003f8:	ee66 6ae7 	vnmul.f32	s13, s13, s15

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
200003fc:	eef4 7ace 	vcmpe.f32	s15, s28
20000400:	eee7 6a06 	vfma.f32	s13, s14, s12
20000404:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000408:	edc4 6a22 	vstr	s13, [r4, #136]	; 0x88
2000040c:	db34      	blt.n	20000478 <_hook_cycle+0x3ce>
2000040e:	eef4 7aed 	vcmpe.f32	s15, s27
20000412:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000416:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2000041a:	bfa8      	it	ge
2000041c:	eef0 7a47 	vmovge.f32	s15, s14
20000420:	e02c      	b.n	2000047c <_hook_cycle+0x3d2>
20000422:	bf00      	nop
20000424:	200008c0 	.word	0x200008c0
20000428:	0800f100 	.word	0x0800f100
2000042c:	3b808081 	.word	0x3b808081
20000430:	37aec33e 	.word	0x37aec33e
20000434:	46b8ff49 	.word	0x46b8ff49
20000438:	36aec33e 	.word	0x36aec33e
2000043c:	3651b717 	.word	0x3651b717
20000440:	0801546c 	.word	0x0801546c
20000444:	080174ec 	.word	0x080174ec
20000448:	080131e8 	.word	0x080131e8
2000044c:	0801abc4 	.word	0x0801abc4
20000450:	0801ca3c 	.word	0x0801ca3c
20000454:	0801915c 	.word	0x0801915c
20000458:	32abcc77 	.word	0x32abcc77
2000045c:	0800ff6c 	.word	0x0800ff6c
20000460:	43000000 	.word	0x43000000
20000464:	3ba3d70a 	.word	0x3ba3d70a
20000468:	3f7eb852 	.word	0x3f7eb852
2000046c:	3fc90fdb 	.word	0x3fc90fdb
20000470:	3ecf817b 	.word	0x3ecf817b
20000474:	3fa2f983 	.word	0x3fa2f983
20000478:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    sig = postlpf.process_fo(sig);
    sig = osc_softclipf(0.125f, sig);
    
	  sig = fasttanf(sig * p.shape * M_PI_2) / M_PI_2 + osc_white() * 0.1;
2000047c:	ee27 7aa7 	vmul.f32	s14, s15, s15
20000480:	eef4 6a00 	vmov.f32	s13, #64	; 0x3e000000  0.125
20000484:	ee27 7ac7 	vnmul.f32	s14, s15, s14
20000488:	ed1f ea08 	vldr	s28, [pc, #-32]	; 2000046c <_hook_cycle+0x3c2>
2000048c:	eee7 7a26 	vfma.f32	s15, s14, s13
20000490:	ed94 7a13 	vldr	s14, [r4, #76]	; 0x4c

  union { float f; uint32_t i; } vx = { x };
  uint32_t sign = vx.i & 0x80000000;
  vx.i = vx.i & 0x7FFFFFFF;

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
20000494:	ed5f 6a0a 	vldr	s13, [pc, #-40]	; 20000470 <_hook_cycle+0x3c6>
20000498:	ee67 7a87 	vmul.f32	s15, s15, s14
2000049c:	ed1f 7a0b 	vldr	s14, [pc, #-44]	; 20000474 <_hook_cycle+0x3ca>
200004a0:	ee67 7a8e 	vmul.f32	s15, s15, s28
  union { float f; uint32_t i; } p = { 0.20363937680730309f };
  union { float f; uint32_t i; } r = { 0.015124940802184233f };
  union { float f; uint32_t i; } s = { -0.0032225901625579573f };

  union { float f; uint32_t i; } vx = { x };
  uint32_t sign = vx.i & 0x80000000;
200004a4:	ee17 3a90 	vmov	r3, s15
200004a8:	f003 4800 	and.w	r8, r3, #2147483648	; 0x80000000
  vx.i = vx.i & 0x7FFFFFFF;
200004ac:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
200004b0:	ee08 3a10 	vmov	s16, r3

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
200004b4:	ee27 8a88 	vmul.f32	s16, s15, s16
200004b8:	ee26 8ac8 	vnmul.f32	s16, s13, s16
200004bc:	eea7 8a87 	vfma.f32	s16, s15, s14
/** "Fast" tangent approximation, valid for x in [-M_PI_2, M_PI_2]
 * @note Adapted from Paul Mineiro's FastFloat
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float fasttanf(float x) {
  return fastsinf(x) / fastsinf(x + M_PI_2);
200004c0:	ee77 7a8e 	vadd.f32	s15, s15, s28
  union { float f; uint32_t i; } vx = { x };
  uint32_t sign = vx.i & 0x80000000;
  vx.i = vx.i & 0x7FFFFFFF;

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
  float qpproxsq = qpprox * qpprox;
200004c4:	ee28 fa08 	vmul.f32	s30, s16, s16
  union { float f; uint32_t i; } p = { 0.20363937680730309f };
  union { float f; uint32_t i; } r = { 0.015124940802184233f };
  union { float f; uint32_t i; } s = { -0.0032225901625579573f };

  union { float f; uint32_t i; } vx = { x };
  uint32_t sign = vx.i & 0x80000000;
200004c8:	ee17 3a90 	vmov	r3, s15
200004cc:	f003 4700 	and.w	r7, r3, #2147483648	; 0x80000000
  vx.i = vx.i & 0x7FFFFFFF;
200004d0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
200004d4:	ee0d 3a90 	vmov	s27, r3

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
200004d8:	ee67 daad 	vmul.f32	s27, s15, s27
200004dc:	ee66 daed 	vnmul.f32	s27, s13, s27
200004e0:	eee7 da87 	vfma.f32	s27, s15, s14
200004e4:	f000 f9e6 	bl	200008b4 <___osc_white_veneer>
  float qpproxsq = qpprox * qpprox;

  p.i |= sign;
  r.i |= sign;
200004e8:	4a33      	ldr	r2, [pc, #204]	; (200005b8 <_hook_cycle+0x50e>)
  s.i ^= sign;
200004ea:	4934      	ldr	r1, [pc, #208]	; (200005bc <_hook_cycle+0x512>)
  vx.i = vx.i & 0x7FFFFFFF;

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
  float qpproxsq = qpprox * qpprox;

  p.i |= sign;
200004ec:	4b34      	ldr	r3, [pc, #208]	; (200005c0 <_hook_cycle+0x516>)
	  real32_t a = sin(((driveValue * _rDrive + 0.01) / 1.02) * M_PI_2);
	  real32_t k = 2 * a / (1.0f - a);
	  signalValue = (1 + k) * (signalValue) / (1 + k * fabs(signalValue));
*/

    *(y++) = f32_to_q31(sig);
200004ee:	ed9f 6a35 	vldr	s12, [pc, #212]	; 200005c4 <_hook_cycle+0x51a>
  r.i |= sign;
200004f2:	ea48 0202 	orr.w	r2, r8, r2
  s.i ^= sign;
200004f6:	ea88 0101 	eor.w	r1, r8, r1
200004fa:	ee07 1a90 	vmov	s15, r1
200004fe:	ee06 2a90 	vmov	s13, r2
20000502:	eeef 6a27 	vfma.f32	s13, s30, s15
  vx.i = vx.i & 0x7FFFFFFF;

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
  float qpproxsq = qpprox * qpprox;

  p.i |= sign;
20000506:	ea48 0303 	orr.w	r3, r8, r3
  r.i |= sign;
2000050a:	4a2b      	ldr	r2, [pc, #172]	; (200005b8 <_hook_cycle+0x50e>)
  s.i ^= sign;
2000050c:	492b      	ldr	r1, [pc, #172]	; (200005bc <_hook_cycle+0x512>)
2000050e:	ee07 3a10 	vmov	s14, r3

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
  float qpproxsq = qpprox * qpprox;

  p.i |= sign;
  r.i |= sign;
20000512:	433a      	orrs	r2, r7
  s.i ^= sign;
20000514:	4079      	eors	r1, r7
  union { float f; uint32_t i; } vx = { x };
  uint32_t sign = vx.i & 0x80000000;
  vx.i = vx.i & 0x7FFFFFFF;

  float qpprox = M_4_PI * x - M_4_PI2 * x * vx.f;
  float qpproxsq = qpprox * qpprox;
20000516:	ee6d eaad 	vmul.f32	s29, s27, s27
2000051a:	eeaf 7a26 	vfma.f32	s14, s30, s13

  p.i |= sign;
2000051e:	4b28      	ldr	r3, [pc, #160]	; (200005c0 <_hook_cycle+0x516>)
20000520:	ee07 1a90 	vmov	s15, r1
20000524:	ee06 2a90 	vmov	s13, r2
20000528:	eeee 6aa7 	vfma.f32	s13, s29, s15
2000052c:	433b      	orrs	r3, r7
2000052e:	ee07 3a90 	vmov	s15, r3
20000532:	eeee 7aa6 	vfma.f32	s15, s29, s13
20000536:	ee27 7a0f 	vmul.f32	s14, s14, s30
2000053a:	ee67 7aae 	vmul.f32	s15, s15, s29
2000053e:	eea8 7a06 	vfma.f32	s14, s16, s12
20000542:	eeed 7a86 	vfma.f32	s15, s27, s12
    phi0 -= (uint32_t)phi0;
    phi1 += s.w01;
    phi1 -= (uint32_t)phi1;
    phisub += s.w0sub;
    phisub -= (uint32_t)phisub;
    lfoz += lfo_inc;
20000546:	ee7c caa9 	vadd.f32	s25, s25, s19
	  real32_t a = sin(((driveValue * _rDrive + 0.01) / 1.02) * M_PI_2);
	  real32_t k = 2 * a / (1.0f - a);
	  signalValue = (1 + k) * (signalValue) / (1 + k * fabs(signalValue));
*/

    *(y++) = f32_to_q31(sig);
2000054a:	eec7 6a27 	vdiv.f32	s13, s14, s15
2000054e:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 200005c8 <_hook_cycle+0x51e>
20000552:	eec6 7a8e 	vdiv.f32	s15, s13, s28
20000556:	eee0 7a07 	vfma.f32	s15, s0, s14
2000055a:	eefe 7ae0 	vcvt.s32.f32	s15, s15, #31
2000055e:	ece5 7a01 	vstmia	r5!, {s15}
    
    phi0 += s.w00;
20000562:	edd4 7a06 	vldr	s15, [r4, #24]
20000566:	ee3c ca27 	vadd.f32	s24, s24, s15
    phi0 -= (uint32_t)phi0;
2000056a:	eefc 7acc 	vcvt.u32.f32	s15, s24
2000056e:	eef8 7a67 	vcvt.f32.u32	s15, s15
20000572:	ee3c ca67 	vsub.f32	s24, s24, s15
    phi1 += s.w01;
20000576:	edd4 7a07 	vldr	s15, [r4, #28]
2000057a:	ee7b baa7 	vadd.f32	s23, s23, s15
    phi1 -= (uint32_t)phi1;
2000057e:	eefc 7aeb 	vcvt.u32.f32	s15, s23
20000582:	eef8 7a67 	vcvt.f32.u32	s15, s15
20000586:	ee7b bae7 	vsub.f32	s23, s23, s15
    phisub += s.w0sub;
2000058a:	edd4 7a08 	vldr	s15, [r4, #32]
2000058e:	ee3b ba27 	vadd.f32	s22, s22, s15
    phisub -= (uint32_t)phisub;
20000592:	eefc 7acb 	vcvt.u32.f32	s15, s22
20000596:	eef8 7a67 	vcvt.f32.u32	s15, s15
2000059a:	ee3b ba67 	vsub.f32	s22, s22, s15
  dsp::BiQuad &postlpf = s_waves.postlpf;
  
  q31_t * __restrict y = (q31_t *)yn;
  const q31_t * y_e = y + frames;
  
  for (; y != y_e; ) {
2000059e:	e661      	b.n	20000264 <_hook_cycle+0x1ba>
    phisub += s.w0sub;
    phisub -= (uint32_t)phisub;
    lfoz += lfo_inc;
  }
  
  s.phi0 = phi0;
200005a0:	ed84 ca03 	vstr	s24, [r4, #12]
  s.phi1 = phi1;
200005a4:	edc4 ba04 	vstr	s23, [r4, #16]
  s.phisub = phisub;
200005a8:	ed84 ba05 	vstr	s22, [r4, #20]
  s.lfoz = lfoz;
200005ac:	edc4 ca0a 	vstr	s25, [r4, #40]	; 0x28
}
200005b0:	ecbd 8b10 	vpop	{d8-d15}
200005b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
200005b8:	3c77ce9a 	.word	0x3c77ce9a
200005bc:	bb533217 	.word	0xbb533217
200005c0:	3e5086d7 	.word	0x3e5086d7
200005c4:	3f48d161 	.word	0x3f48d161
200005c8:	3dcccccd 	.word	0x3dcccccd

200005cc <_hook_on>:

void OSC_NOTEON(const user_osc_param_t * const params)
{
  s_waves.state.flags |= Waves::k_flag_reset;
200005cc:	4a03      	ldr	r2, [pc, #12]	; (200005dc <_hook_on+0x10>)
200005ce:	f892 303c 	ldrb.w	r3, [r2, #60]	; 0x3c
200005d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
200005d6:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
200005da:	4770      	bx	lr
200005dc:	200008c0 	.word	0x200008c0

200005e0 <_hook_off>:
}

void OSC_NOTEOFF(const user_osc_param_t * const params)
{
200005e0:	4770      	bx	lr

200005e2 <_hook_param>:
void OSC_PARAM(uint16_t index, uint16_t value)
{ 
  Waves::Params &p = s_waves.params;
  Waves::State &s = s_waves.state;
  
  switch (index) {
200005e2:	2807      	cmp	r0, #7
200005e4:	f200 80ae 	bhi.w	20000744 <_hook_param+0x162>
200005e8:	e8df f000 	tbb	[pc, r0]
200005ec:	2e221304 	.word	0x2e221304
200005f0:	9f937053 	.word	0x9f937053
  case k_user_osc_param_id1:
    // wave 0
    // select parameter
    {
      static const uint8_t cnt = k_waves_a_cnt + k_waves_b_cnt + k_waves_c_cnt; 
      p.wave0 = value % cnt;
200005f4:	4b54      	ldr	r3, [pc, #336]	; (20000748 <_hook_param+0x166>)
200005f6:	202e      	movs	r0, #46	; 0x2e
200005f8:	fbb1 f2f0 	udiv	r2, r1, r0
200005fc:	fb00 1112 	mls	r1, r0, r2, r1
      s.flags |= Waves::k_flag_wave0;
20000600:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
  case k_user_osc_param_id1:
    // wave 0
    // select parameter
    {
      static const uint8_t cnt = k_waves_a_cnt + k_waves_b_cnt + k_waves_c_cnt; 
      p.wave0 = value % cnt;
20000604:	f883 1054 	strb.w	r1, [r3, #84]	; 0x54
      s.flags |= Waves::k_flag_wave0;
20000608:	f042 0202 	orr.w	r2, r2, #2
2000060c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    break;
20000610:	4770      	bx	lr
  case k_user_osc_param_id2:
    // wave 1
    // select parameter
    {
      static const uint8_t cnt = k_waves_d_cnt + k_waves_e_cnt + k_waves_f_cnt; 
      p.wave1 = value % cnt;
20000612:	4b4d      	ldr	r3, [pc, #308]	; (20000748 <_hook_param+0x166>)
20000614:	202c      	movs	r0, #44	; 0x2c
20000616:	fbb1 f2f0 	udiv	r2, r1, r0
2000061a:	fb00 1112 	mls	r1, r0, r2, r1
      s.flags |= Waves::k_flag_wave1;
2000061e:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
  case k_user_osc_param_id2:
    // wave 1
    // select parameter
    {
      static const uint8_t cnt = k_waves_d_cnt + k_waves_e_cnt + k_waves_f_cnt; 
      p.wave1 = value % cnt;
20000622:	f883 1055 	strb.w	r1, [r3, #85]	; 0x55
      s.flags |= Waves::k_flag_wave1;
20000626:	f042 0204 	orr.w	r2, r2, #4
2000062a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    break;
2000062e:	4770      	bx	lr
    
  case k_user_osc_param_id3:
    // sub wave
    // select parameter
    p.subwave = value % k_waves_a_cnt;
20000630:	4b45      	ldr	r3, [pc, #276]	; (20000748 <_hook_param+0x166>)
    s.flags |= Waves::k_flag_subwave;
20000632:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    break;
    
  case k_user_osc_param_id3:
    // sub wave
    // select parameter
    p.subwave = value % k_waves_a_cnt;
20000636:	f001 010f 	and.w	r1, r1, #15
    s.flags |= Waves::k_flag_subwave;
2000063a:	f042 0208 	orr.w	r2, r2, #8
    break;
    
  case k_user_osc_param_id3:
    // sub wave
    // select parameter
    p.subwave = value % k_waves_a_cnt;
2000063e:	f883 1056 	strb.w	r1, [r3, #86]	; 0x56
    s.flags |= Waves::k_flag_subwave;
20000642:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    break;
20000646:	4770      	bx	lr
    
  case k_user_osc_param_id4:
    // sub mix
    // percent parameter
    p.submix = clip01f(0.05f + value * 0.01f * 0.90f); // scale in 0.05 - 0.95
20000648:	ee07 1a90 	vmov	s15, r1
2000064c:	ed9f 7a3f 	vldr	s14, [pc, #252]	; 2000074c <_hook_param+0x16a>
20000650:	eddf 6a3f 	vldr	s13, [pc, #252]	; 20000750 <_hook_param+0x16e>
20000654:	eef8 7ae7 	vcvt.f32.s32	s15, s15
20000658:	ee67 7a87 	vmul.f32	s15, s15, s14
2000065c:	ed9f 7a3d 	vldr	s14, [pc, #244]	; 20000754 <_hook_param+0x172>
20000660:	eea7 7aa6 	vfma.f32	s14, s15, s13

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000664:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
20000668:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000066c:	eef0 7a47 	vmov.f32	s15, s14
20000670:	db09      	blt.n	20000686 <_hook_param+0xa4>
20000672:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
20000676:	eef4 7ac7 	vcmpe.f32	s15, s14
2000067a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000067e:	bfa8      	it	ge
20000680:	eef0 7a47 	vmovge.f32	s15, s14
20000684:	e001      	b.n	2000068a <_hook_param+0xa8>
20000686:	eddf 7a34 	vldr	s15, [pc, #208]	; 20000758 <_hook_param+0x176>
2000068a:	4b2f      	ldr	r3, [pc, #188]	; (20000748 <_hook_param+0x166>)
2000068c:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
    break;
20000690:	4770      	bx	lr
    
  case k_user_osc_param_id5:
    // ring mix
    // percent parameter
    p.ringmix = clip01f(value * 0.01f);
20000692:	ee07 1a90 	vmov	s15, r1
20000696:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 2000074c <_hook_param+0x16a>
2000069a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2000069e:	ee67 7a87 	vmul.f32	s15, s15, s14
200006a2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
200006a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006aa:	db09      	blt.n	200006c0 <_hook_param+0xde>
200006ac:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
200006b0:	eef4 7ac7 	vcmpe.f32	s15, s14
200006b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006b8:	bfa8      	it	ge
200006ba:	eef0 7a47 	vmovge.f32	s15, s14
200006be:	e001      	b.n	200006c4 <_hook_param+0xe2>
200006c0:	eddf 7a25 	vldr	s15, [pc, #148]	; 20000758 <_hook_param+0x176>
200006c4:	4b20      	ldr	r3, [pc, #128]	; (20000748 <_hook_param+0x166>)
200006c6:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
    break;
200006ca:	4770      	bx	lr
    
  case k_user_osc_param_id6:
    // bit crush
    // percent parameter
    p.bitcrush = clip01f(value * 0.01f);
200006cc:	ee07 1a90 	vmov	s15, r1
200006d0:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 2000074c <_hook_param+0x16a>
200006d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
200006d8:	ee67 7a87 	vmul.f32	s15, s15, s14
200006dc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
200006e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006e4:	db09      	blt.n	200006fa <_hook_param+0x118>
200006e6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
200006ea:	eef4 7ac7 	vcmpe.f32	s15, s14
200006ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006f2:	bfa8      	it	ge
200006f4:	eef0 7a47 	vmovge.f32	s15, s14
200006f8:	e001      	b.n	200006fe <_hook_param+0x11c>
200006fa:	eddf 7a17 	vldr	s15, [pc, #92]	; 20000758 <_hook_param+0x176>
200006fe:	4b12      	ldr	r3, [pc, #72]	; (20000748 <_hook_param+0x166>)
    s.flags |= Waves::k_flag_bitcrush;
20000700:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    break;
    
  case k_user_osc_param_id6:
    // bit crush
    // percent parameter
    p.bitcrush = clip01f(value * 0.01f);
20000704:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
    s.flags |= Waves::k_flag_bitcrush;
20000708:	f042 0220 	orr.w	r2, r2, #32
2000070c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    break;
20000710:	4770      	bx	lr
    
  case k_user_osc_param_shape:
    // 10bit parameter
    p.shape = param_val_to_f32(value);
20000712:	ee07 1a90 	vmov	s15, r1
20000716:	ed9f 7a11 	vldr	s14, [pc, #68]	; 2000075c <_hook_param+0x17a>
2000071a:	4b0b      	ldr	r3, [pc, #44]	; (20000748 <_hook_param+0x166>)
2000071c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
20000720:	ee67 7a87 	vmul.f32	s15, s15, s14
20000724:	edc3 7a13 	vstr	s15, [r3, #76]	; 0x4c
    break;
20000728:	4770      	bx	lr
    
  case k_user_osc_param_shiftshape:
    // 10bit parameter
    p.shiftshape = 1.f + param_val_to_f32(value); 
2000072a:	ee07 1a90 	vmov	s15, r1
2000072e:	eddf 6a0b 	vldr	s13, [pc, #44]	; 2000075c <_hook_param+0x17a>
20000732:	4b05      	ldr	r3, [pc, #20]	; (20000748 <_hook_param+0x166>)
20000734:	eef8 7ae7 	vcvt.f32.s32	s15, s15
20000738:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2000073c:	eea7 7aa6 	vfma.f32	s14, s15, s13
20000740:	ed83 7a14 	vstr	s14, [r3, #80]	; 0x50
20000744:	4770      	bx	lr
20000746:	bf00      	nop
20000748:	200008c0 	.word	0x200008c0
2000074c:	3c23d70a 	.word	0x3c23d70a
20000750:	3f666666 	.word	0x3f666666
20000754:	3d4ccccd 	.word	0x3d4ccccd
20000758:	00000000 	.word	0x00000000
2000075c:	3a802008 	.word	0x3a802008

20000760 <_ZN5Waves5StateC1Ev>:
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
      wave0(wavesA[0]),
20000760:	4b12      	ldr	r3, [pc, #72]	; (200007ac <_ZN5Waves5StateC1Ev+0x4c>)
      wave1(wavesD[0]),
20000762:	4a13      	ldr	r2, [pc, #76]	; (200007b0 <_ZN5Waves5StateC1Ev+0x50>)
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
      wave0(wavesA[0]),
20000764:	681b      	ldr	r3, [r3, #0]
      lfo(0.f),
      lfoz(0.f),
      dither(0.f),
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
20000766:	6812      	ldr	r2, [r2, #0]
          float    bitres;
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
20000768:	b510      	push	{r4, lr}
      lfo(0.f),
      lfoz(0.f),
      dither(0.f),
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
2000076a:	6003      	str	r3, [r0, #0]
2000076c:	6083      	str	r3, [r0, #8]
2000076e:	4b11      	ldr	r3, [pc, #68]	; (200007b4 <_ZN5Waves5StateC1Ev+0x54>)
20000770:	6042      	str	r2, [r0, #4]
20000772:	6183      	str	r3, [r0, #24]
20000774:	61c3      	str	r3, [r0, #28]
20000776:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
2000077a:	4b0f      	ldr	r3, [pc, #60]	; (200007b8 <_ZN5Waves5StateC1Ev+0x58>)
2000077c:	6203      	str	r3, [r0, #32]
2000077e:	6302      	str	r2, [r0, #48]	; 0x30
20000780:	2300      	movs	r3, #0
20000782:	6342      	str	r2, [r0, #52]	; 0x34
20000784:	2200      	movs	r2, #0
20000786:	6243      	str	r3, [r0, #36]	; 0x24
20000788:	6283      	str	r3, [r0, #40]	; 0x28
2000078a:	62c3      	str	r3, [r0, #44]	; 0x2c
2000078c:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
    }
    
    inline void reset(void)
    {
      phi0 = 0;
20000790:	60c3      	str	r3, [r0, #12]
      phi1 = 0;
20000792:	6103      	str	r3, [r0, #16]
      phisub = 0;
20000794:	6143      	str	r3, [r0, #20]
          float    bitres;
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
20000796:	4604      	mov	r4, r0
20000798:	f000 f88c 	bl	200008b4 <___osc_white_veneer>
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
    {
      reset();
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
2000079c:	eddf 7a07 	vldr	s15, [pc, #28]	; 200007bc <_ZN5Waves5StateC1Ev+0x5c>
200007a0:	ee20 0a27 	vmul.f32	s0, s0, s15
    }
200007a4:	4620      	mov	r0, r4
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
    {
      reset();
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
200007a6:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
    }
200007aa:	bd10      	pop	{r4, pc}
200007ac:	080131e8 	.word	0x080131e8
200007b0:	0801915c 	.word	0x0801915c
200007b4:	3c162fc9 	.word	0x3c162fc9
200007b8:	3b962fc9 	.word	0x3b962fc9
200007bc:	358bd08a 	.word	0x358bd08a

200007c0 <_GLOBAL__sub_I__hook_init>:
    break;
    
  default:
    break;
  }
}
200007c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
      phisub = 0;
      lfo = lfoz;
    }
  };

  Waves(void) {
200007c4:	4c35      	ldr	r4, [pc, #212]	; (2000089c <_GLOBAL__sub_I__hook_init+0xdc>)
      bitcrush(0.f),
      shape(0.f),
      shiftshape(0.f),
      wave0(0),
      wave1(0),
      subwave(0)
200007c6:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 200008b0 <_GLOBAL__sub_I__hook_init+0xf0>
200007ca:	b091      	sub	sp, #68	; 0x44
      phisub = 0;
      lfo = lfoz;
    }
  };

  Waves(void) {
200007cc:	4620      	mov	r0, r4
200007ce:	f7ff ffc7 	bl	20000760 <_ZN5Waves5StateC1Ev>
      bitcrush(0.f),
      shape(0.f),
      shiftshape(0.f),
      wave0(0),
      wave1(0),
      subwave(0)
200007d2:	2500      	movs	r5, #0
200007d4:	f04f 0800 	mov.w	r8, #0
  Waves(void) {
    init();
  }

  void init(void) {
    state = State();
200007d8:	4668      	mov	r0, sp
200007da:	466e      	mov	r6, sp
      bitcrush(0.f),
      shape(0.f),
      shiftshape(0.f),
      wave0(0),
      wave1(0),
      subwave(0)
200007dc:	f8c4 9040 	str.w	r9, [r4, #64]	; 0x40
200007e0:	6465      	str	r5, [r4, #68]	; 0x44
200007e2:	64a5      	str	r5, [r4, #72]	; 0x48
200007e4:	64e5      	str	r5, [r4, #76]	; 0x4c
200007e6:	6525      	str	r5, [r4, #80]	; 0x50
200007e8:	f884 8054 	strb.w	r8, [r4, #84]	; 0x54
200007ec:	f884 8055 	strb.w	r8, [r4, #85]	; 0x55
200007f0:	f884 8056 	strb.w	r8, [r4, #86]	; 0x56
      /**
       * Default constructor
       */
      Coeffs() :
        ff0(0), ff1(0), ff2(0),
        fb1(0), fb2(0)
200007f4:	65a5      	str	r5, [r4, #88]	; 0x58
200007f6:	65e5      	str	r5, [r4, #92]	; 0x5c
200007f8:	6625      	str	r5, [r4, #96]	; 0x60
200007fa:	6665      	str	r5, [r4, #100]	; 0x64
200007fc:	66a5      	str	r5, [r4, #104]	; 0x68
    /*=====================================================================*/

    /**
     * Default constructor
     */
    BiQuad(void) : mZ1(0), mZ2(0)
200007fe:	66e5      	str	r5, [r4, #108]	; 0x6c
20000800:	6725      	str	r5, [r4, #112]	; 0x70
      /**
       * Default constructor
       */
      Coeffs() :
        ff0(0), ff1(0), ff2(0),
        fb1(0), fb2(0)
20000802:	6765      	str	r5, [r4, #116]	; 0x74
20000804:	67a5      	str	r5, [r4, #120]	; 0x78
20000806:	67e5      	str	r5, [r4, #124]	; 0x7c
20000808:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
2000080c:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
    /*=====================================================================*/

    /**
     * Default constructor
     */
    BiQuad(void) : mZ1(0), mZ2(0)
20000810:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
20000814:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  Waves(void) {
    init();
  }

  void init(void) {
    state = State();
20000818:	f7ff ffa2 	bl	20000760 <_ZN5Waves5StateC1Ev>
2000081c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
2000081e:	4627      	mov	r7, r4
20000820:	c70f      	stmia	r7!, {r0, r1, r2, r3}
20000822:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
20000824:	c70f      	stmia	r7!, {r0, r1, r2, r3}
20000826:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
20000828:	c70f      	stmia	r7!, {r0, r1, r2, r3}
2000082a:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
2000082e:	c707      	stmia	r7!, {r0, r1, r2}
20000830:	703b      	strb	r3, [r7, #0]
       *
       * @param   pole Pole position in radians
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setPoleLP(const float pole) {
        ff0 = 1.f - pole;
20000832:	4b1b      	ldr	r3, [pc, #108]	; (200008a0 <_GLOBAL__sub_I__hook_init+0xe0>)
    params = Params();
20000834:	f8c4 9040 	str.w	r9, [r4, #64]	; 0x40
20000838:	65a3      	str	r3, [r4, #88]	; 0x58
        fb1 = -pole;
2000083a:	4b1a      	ldr	r3, [pc, #104]	; (200008a4 <_GLOBAL__sub_I__hook_init+0xe4>)
2000083c:	6663      	str	r3, [r4, #100]	; 0x64
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_tanpif(float x) {
    const float idxf = x * k_tanpi_range_recip * k_tanpi_size;
    const uint32_t idx = (uint32_t)idxf;
    const float y0 = tanpi_lut_f[idx];
2000083e:	4b1a      	ldr	r3, [pc, #104]	; (200008a8 <_GLOBAL__sub_I__hook_init+0xe8>)

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000840:	eddf 6a1a 	vldr	s13, [pc, #104]	; 200008ac <_GLOBAL__sub_I__hook_init+0xec>
20000844:	edd3 7aeb 	vldr	s15, [r3, #940]	; 0x3ac
20000848:	ed93 7aec 	vldr	s14, [r3, #944]	; 0x3b0
2000084c:	6465      	str	r5, [r4, #68]	; 0x44
2000084e:	ee37 7a67 	vsub.f32	s14, s14, s15
20000852:	64a5      	str	r5, [r4, #72]	; 0x48
20000854:	eee7 7a26 	vfma.f32	s15, s14, s13
20000858:	64e5      	str	r5, [r4, #76]	; 0x4c
2000085a:	6525      	str	r5, [r4, #80]	; 0x50
       *
       * @param   k Tangent of PI x cutoff frequency in radians: tan(pi*wc)
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
2000085c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
20000860:	ee37 7aa6 	vadd.f32	s14, s15, s13
20000864:	f884 8054 	strb.w	r8, [r4, #84]	; 0x54
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
20000868:	ee87 6a87 	vdiv.f32	s12, s15, s14
2000086c:	f884 8055 	strb.w	r8, [r4, #85]	; 0x55
20000870:	f884 8056 	strb.w	r8, [r4, #86]	; 0x56
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setPoleLP(const float pole) {
        ff0 = 1.f - pole;
        fb1 = -pole;
        fb2 = ff2 = ff1 = 0.f;
20000874:	65e5      	str	r5, [r4, #92]	; 0x5c
20000876:	6625      	str	r5, [r4, #96]	; 0x60
20000878:	66a5      	str	r5, [r4, #104]	; 0x68
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
        fb1 = km1 / kp1;
        fb2 = ff2 = 0.f;
2000087a:	67e5      	str	r5, [r4, #124]	; 0x7c
2000087c:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
        fb1 = km1 / kp1;
20000880:	ee77 7ae6 	vsub.f32	s15, s15, s13
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
20000884:	ed84 6a1e 	vstr	s12, [r4, #120]	; 0x78
        fb1 = km1 / kp1;
20000888:	eec7 6a87 	vdiv.f32	s13, s15, s14
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
2000088c:	ed84 6a1d 	vstr	s12, [r4, #116]	; 0x74
        fb1 = km1 / kp1;
20000890:	edc4 6a20 	vstr	s13, [r4, #128]	; 0x80
20000894:	b011      	add	sp, #68	; 0x44
20000896:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
2000089a:	bf00      	nop
2000089c:	200008c0 	.word	0x200008c0
200008a0:	3e4ccccc 	.word	0x3e4ccccc
200008a4:	bf4ccccd 	.word	0xbf4ccccd
200008a8:	0800f764 	.word	0x0800f764
200008ac:	3dd0f800 	.word	0x3dd0f800
200008b0:	3d4ccccd 	.word	0x3d4ccccd

200008b4 <___osc_white_veneer>:
200008b4:	f85f f000 	ldr.w	pc, [pc]	; 200008b8 <___osc_white_veneer+0x4>
200008b8:	0801edb9 	.word	0x0801edb9
